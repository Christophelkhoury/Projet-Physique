<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Machine Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; text-align: center; font-family: Arial, sans-serif; }
        canvas { display: block; }
        .controls, .timeline, .equations, .graph, .annotations, .observer-controls {
            position: absolute;
            z-index: 10;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
        }
        .controls { top: 10px; left: 10px; }
        .timeline { bottom: 10px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; }
        .timeline div { padding: 5px 10px; border: 1px solid black; border-radius: 5px; font-weight: bold; }
        .equations { top: 10px; right: 10px; font-weight: bold; font-size: 18px; }
        .graph { bottom: 10px; right: 10px; width: 300px; height: 150px; border: 1px solid black; display: block; }
        .annotations { top: 50px; left: 50%; transform: translateX(-50%); font-size: 18px; font-weight: bold; }
        .observer-controls { top: 90px; left: 10px; }
        #observer-checkbox { margin-right: 5px; }
        .speed-slider { margin-top: 10px; }
        .info-button, .info-button-2 {
            position: absolute;
            bottom: 190px; /* Adjusted to be at the same level as the top of the graph */
            background: rgba(255, 255, 255, 0.8);
            padding: 5px;
            border-radius: 5px;
            font-size: 12px;
            cursor: pointer;
            border: 1px solid black;
        }
        .info-button { left: 39%; transform: translateX(-50%); }
        .info-button-2 { left: 26%; transform: translateX(-50%); } /* Adjusted position */
        .info-box, .info-box-2 {
            display: none;
            position: absolute;
            background: white;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid black;
            width: 250px;
            text-align: left;
            font-size: 12px; /* Smaller text */
        }
        .info-box { bottom: 70px; left: 50%; transform: translateX(-50%); }
        .info-box-2 { bottom: 0%; left: 15%; transform: translateX(-50%); } /* Moved towards the bottom */
        .explanation-button {
            position: absolute;
            bottom: 0px; /* Adjusted to be at the same level as the top of the graph */
            left: 5%; /* Moved more to the left */
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.8);
            padding: 20px; /* Made the button bigger */
            border-radius: 5px;
            font-size: 20px; /* Increased font size */
            cursor: pointer;
            border: 1px solid black;
        }

        .explanation-box {
            display: none;
            position: absolute;
            top: 0; /* Take up the whole height from top */
            bottom: 0; /* to bottom */
            right: 0; /* Positioned on the right */
            width: 25%; /* Width about a fourth of the page */
            background: white;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid black;
            text-align: left;
            font-size: 16px; /* Larger text */
            overflow-y: auto; /* Add scroll if content overflows */
            z-index: 20; /* Ensure it covers other elements */
        }
        .highlight {
            background-color: yellow; /* Highlight color */
        }
        .controls button {
            font-size: 18px; /* Bigger buttons */
            padding: 10px 20px; /* More padding */
        }
    </style>
</head>
<body>
    <div class="controls">
        <button onclick="startExperiment()">Start Experiment</button>
        <button onclick="rotateView()">Rotate View</button>
    </div>

    <div class="observer-controls">
        <label for="observer-checkbox">Observer:</label>
        <input type="checkbox" id="observer-checkbox" onchange="toggleObserver()">
        <br>
        <label for="speed-slider">Animation Speed:</label>
        <input type="range" id="speed-slider" class="speed-slider" min="3" max="3.5" step="0.1" value="3" onchange="updateAnimationSpeed(this.value)">
    </div>

    <div class="timeline" id="timeline">
        <div id="stage1">Schrödinger's Cat</div>
        <div id="stage2">Young's Double-Slit</div>
        <div id="stage3">Electron Absorption</div>
    </div>

    <div class="equations" id="equations">Equation: N/A</div>
    <canvas class="graph" id="graph"></canvas>
    <div class="annotations" id="annotations">
        <strong>This is an improved version of a solar panel</strong><br>
        Welcome to the Quantum Experiment
    </div>
    <div class="panel-number" style="position: absolute; top: 20px; left: 20%; font-size: 24px; font-weight: bold;">1</div>
    <div class="panel-number" style="position: absolute; top: 20px; left: 40%; font-size: 24px; font-weight: bold;">2</div>
    <div class="panel-number" style="position: absolute; top: 20px; left: 60%; font-size: 24px; font-weight: bold;">3</div>
    <div class="panel-number" style="position: absolute; top: 20px; left: 80%; font-size: 24px; font-weight: bold;">4</div>

    <div class="explanation-button" id="explanation-button" onclick="toggleExplanation()">Explanation</div>
    <div class="explanation-box" id="explanation-box">
    <em style="font-size: 16px; color: red; font-weight: bold;">Note: Click on the text to highlight the corresponding part of the machine.</em><br><br>
    <strong style="font-size: 18px;">Towards a More Efficient Solar Panel Thanks to Quantum Physics</strong><br><br>
    <ul style="font-size: 16px;">
        <li id="explanation-empty-space" onclick="highlightPart('empty-space')"><strong>Empty Space (Before the First Panel) – Schrödinger’s Superposition</strong><br>
            Before reaching any physical barrier, photons exist in a superposition state, meaning they have the potential to take multiple paths at once. Their behavior remains undefined until they interact with the system.
        </li><br>
        <li id="explanation-first-panel" onclick="highlightPart('first-panel')"><strong>First Panel (Metal with Two Slits) – Quantum Measurement Effect</strong><br>
            <em>Without Observation:</em> Photons pass through both slits simultaneously as waves, forming an interference pattern beyond this panel.<br>
            <em>With Observation:</em> Photons act as particles, traveling through one slit only, preventing interference.
        </li><br>
        <li id="explanation-second-third-panel" onclick="highlightPart('second-third-panel')"><strong>Space Between the Second and Third Panel – Young’s Interference Theory</strong><br>
            <em>Without Observation:</em> The interference pattern spreads across this space, causing light redistribution, concentrating photons in specific regions before they reach the semiconductor.<br>
            <em>With Observation:</em> The photons travel in straight, separate trajectories, arriving at the semiconductor panel without interference effects.
        </li><br>
        <li id="explanation-third-panel" onclick="highlightPart('third-panel')"><strong>Third Panel (Semiconductor – Silicon) – Electron Absorption and Energy Conversion</strong><br>
            Here, electrons absorb photons, gaining energy and increasing speed.<br>
            The amount of energy gained depends on photon distribution, which is influenced by earlier interference.<br>
            Efficient absorption leads to higher electricity conversion, making quantum effects crucial to optimizing energy output.
        </li><br>
    </ul>
    <strong>Conclusion</strong><br>
    By leveraging quantum effects at different stages, light absorption and energy conversion can be optimized. Understanding and controlling these phenomena may lead to more efficient solar panels in the future.
</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script>
        let scene, camera, renderer, lightBeam, box, slitPanel, semiconductor;
        let stageIndex = 0, viewAngle = 0, energyGraphCtx, graphX = 0, graphY = 0;
        let photons = [];  // To store the photon objects
        let electrons = []; // To store the electron objects
        let graphStarted = false; // Track when the graph starts
        let animationSpeed = 2; // Default animation speed (set to 0.25)
        let observerPresent = false; // Toggle for observer presence (false by default)
        let firstPanel, secondPanel, thirdPanel;
        
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Create a box divided into three parts
            const boxGeometry = new THREE.BoxGeometry(10, 3, 1); // Adjusted width
            const boxMaterial = new THREE.MeshBasicMaterial({ color: 0x808080, wireframe: true });
            box = new THREE.Mesh(boxGeometry, boxMaterial);
            scene.add(box);

            // Create the first panel with no slits (will have rectangular holes)
            const firstPanelGeometry = new THREE.BoxGeometry(0.1, 3, 1); // Panel size
            const firstPanelMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.3 }); // Changed to white
            firstPanel = new THREE.Mesh(firstPanelGeometry, firstPanelMaterial);
            firstPanel.position.set(-5, 0, 0); // Move the first panel
            scene.add(firstPanel);

            // Create the second divider with two rectangular holes
            const secondPanelGeometry = new THREE.BoxGeometry(0.3, 3, 1); // Wider divider size
            const secondPanelMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.3 });
            secondPanel = new THREE.Mesh(secondPanelGeometry, secondPanelMaterial);
            secondPanel.position.set(-2, 0, 0); // Move the second divider to the left
            scene.add(secondPanel);

            // Create the two rectangular holes with white borders
            const holeGeometry = new THREE.BoxGeometry(0.6, 0.1, 1); // Less wide horizontal hole size (wider in x, thinner in y)
            const holeMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 1 });
            
            const hole1 = new THREE.Mesh(holeGeometry, holeMaterial);
            const hole2 = new THREE.Mesh(holeGeometry, holeMaterial);
            
            // Position holes horizontally, spaced equally
            hole1.position.set(-2, 0.5, 0); // Upper hole
            hole2.position.set(-2, -0.5, 0); // Lower hole
            
            scene.add(hole1);
            scene.add(hole2);
            
            // Create white border effect for the holes
            const borderGeometry = new THREE.BoxGeometry(0.7, 0.2, 1); // Border size
            const borderMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff }); // White border
            
            const border1 = new THREE.Mesh(borderGeometry, borderMaterial);
            const border2 = new THREE.Mesh(borderGeometry, borderMaterial);
            
            // Position the borders around the holes
            border1.position.set(-2, 0.5, 0); 
            border2.position.set(-2, -0.5, 0);
            scene.add(border1);
            scene.add(border2);

            // Create the third divider (no holes) with a different color and wider size
            const thirdPanelGeometry = new THREE.BoxGeometry(0.4, 3, 1); // Wider divider size
            const thirdPanelMaterial = new THREE.MeshBasicMaterial({ color:0xffffff, transparent: true, opacity: 0.3 }); // Changed to white
            thirdPanel = new THREE.Mesh(thirdPanelGeometry, thirdPanelMaterial);
            thirdPanel.position.set(1.33, 0, 0); // Move the third divider to the left
            scene.add(thirdPanel);

            // Create light beam (adjust the position)
            const beamGeometry = new THREE.CylinderGeometry(0.05, 0.05, 5, 32);
            const beamMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.8 });
            lightBeam = new THREE.Mesh(beamGeometry, beamMaterial);
            lightBeam.rotation.z = Math.PI / 2;
            lightBeam.position.set(-5, 0, 0); // Adjusted position
            scene.add(lightBeam);

            // Add numbers above the panels
            addNumber(-5, 2, "1");
            addNumber(-2, 2, "2");
            addNumber(1.33, 2, "3");
            addNumber(4, 2, "4");

            // Setup canvas for energy graph
            energyGraphCtx = document.getElementById("graph").getContext("2d");
            energyGraphCtx.clearRect(0, 0, 300, 150); // Clear previous drawings

            // Draw initial axis labels only once
            energyGraphCtx.font = "12px Arial";
            energyGraphCtx.fillText("Energy", 10, 10); // Y-axis label
            energyGraphCtx.fillText("Time", 230, 140); // X-axis label
            energyGraphCtx.fillText("Speed", 230, 20); // Speed label near the top

            camera.position.z = 5;
            animate();
        }

        function addNumber(x, y, text) {
            const loader = new THREE.FontLoader();
            loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
                const textGeometry = new THREE.TextGeometry(text, {
                    font: font,
                    size: 0.5,
                    height: 0.1,
                });
                const textMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const mesh = new THREE.Mesh(textGeometry, textMaterial);
                mesh.position.set(x, y, 0);
                scene.add(mesh);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function resetExperiment() {
            // Reset all elements to their initial positions before starting again
            lightBeam.position.set(-5, 0, 0); // Reset light beam position
            photons.forEach(p => scene.remove(p)); // Remove any existing photons
            electrons.forEach(e => scene.remove(e)); // Remove any existing electrons
            photons = []; // Reset photon array
            electrons = []; // Reset electron array
            graphStarted = false; // Reset graph flag
            energyGraphCtx.clearRect(0, 0, 300, 150); // Clear the graph
            graphX = 0;
            graphY = 0;

            // Redraw initial axis labels
            energyGraphCtx.font = "12px Arial";
            energyGraphCtx.fillText("Energy", 10, 10); // Y-axis label
            energyGraphCtx.fillText("Time", 230, 140); // X-axis label
            energyGraphCtx.fillText("Speed", 230, 20); // Speed label near the top
        }

        function startExperiment() {
            resetExperiment(); // Reset everything before starting the experiment
            document.querySelector(".graph").style.display = "block"; // Show graph when experiment starts
            updateEquations("Schrödinger's Equation: Ψ(x,t) = A * exp(i(kx - ωt))");
            updateAnnotations("Schrödinger's Equation Determines Path Probability");
            gsap.to(lightBeam.position, { x: -2, duration: animationSpeed, ease: "power1.inOut", onComplete: () => {
                updateEquations("Young's Double-Slit: I(x) = I0 * cos²(π * x / λ)");
                updateAnnotations("Young's Double-Slit Experiment - Light Interference");
                showPhotons(); // Show photons gradually as beam moves
                if (!graphStarted) startGraph(); // Start drawing the graph once the experiment begins
                gsap.to(lightBeam.position, { x: 1.33, duration: animationSpeed, ease: "power1.inOut", onComplete: () => {
                    updateEquations("Electron Absorption: E = hν + ½mv²");
                    updateAnnotations("Electron Absorption - Energy Gain");
                    showElectrons(); // Show electrons after photon interaction
                    gsap.to(lightBeam.position, { x: 4, duration: animationSpeed, ease: "power1.inOut", onComplete: () => {
                        updateEnergyGraph(50); // Update the graph to show energy gain
                        updateAnnotations("Experiment Complete!"); // Final annotation
                    }}); 
                }}); 
            }}); 
        }

        function startGraph() {
            graphStarted = true;
            updateEnergyGraph(5); // Start the graph drawing on first step
        }

        function showPhotons() {
            // Gradually show photons (with observer behavior)
            for (let i = -0.5; i <= 0.5; i += 0.1) {
                setTimeout(() => {
                    const dotGeometry = new THREE.SphereGeometry(0.05, 32, 32);
                    const dotMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                    const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                    
                    if (observerPresent) {
                        // Horizontal arrangement when observer is present
                        dot.position.set(lightBeam.position.x + i, 0, 0);
                    } else {
                        // Vertical arrangement when no observer
                        dot.position.set(lightBeam.position.x, i, 0);
                    }

                    scene.add(dot); // Add each dot to the scene
                    photons.push(dot); // Store the photon for later removal
                }, 500); // Delay the appearance of each photon
            }
        }

        function showElectrons() {
            // Gradually show electrons (with observer behavior)
            for (let i = -0.5; i <= 0.5; i += 0.05) {
                setTimeout(() => {
                    const dotGeometry = new THREE.SphereGeometry(0.025, 32, 32);
                    const dotMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                    const dot = new THREE.Mesh(dotGeometry, dotMaterial);

                    if (observerPresent) {
                        // Horizontal arrangement when observer is present
                        dot.position.set(lightBeam.position.x + i, 0, 0);
                    } else {
                        // Vertical arrangement when no observer
                        dot.position.set(lightBeam.position.x, i, 0);
                    }

                    scene.add(dot); // Add each dot to the scene
                    electrons.push(dot); // Store the electron for later removal
                }, 500); // Delay the appearance of each electron
            }
        }

        function toggleObserver() {
            observerPresent = document.getElementById("observer-checkbox").checked;
            updateAnnotations(observerPresent ? "Observer Present" : "No Observer");
        }

        function updateAnimationSpeed(speed) {
            animationSpeed = speed;
        }

        function updateEquations(text) {
            document.getElementById("equations").innerText = "Equation: " + text;
        }

        function updateAnnotations(text) {
            document.getElementById("annotations").innerText = text;
        }

        function updateEnergyGraph(energy) {
            energyGraphCtx.beginPath();
            energyGraphCtx.moveTo(graphX, graphY);
            graphX += 10;
            graphY = 150 - energy;
            energyGraphCtx.lineTo(graphX, graphY);
            energyGraphCtx.strokeStyle = '#ff0000';
            energyGraphCtx.stroke();
        }

        function rotateView() {
            viewAngle += Math.PI / 2; // Rotate the camera by 90 degrees
            gsap.to(camera.position, {
                duration: 1,
                x: 5 * Math.cos(viewAngle),
                z: 5 * Math.sin(viewAngle),
                onUpdate: () => camera.lookAt(scene.position)
            });
        }
        function highlightPart(part) {
    // Reset all highlights and opacity states
    resetHighlights();

    // Highlight the corresponding text and animation part based on the selected part
    switch(part) {
        case "empty-space":
            document.getElementById("explanation-empty-space").classList.add("highlight");
            if (firstPanel) firstPanel.material.opacity = 1; // Highlighting the first panel (empty space)
            updateAnnotations("Empty Space (Before the First Panel) - Schrödinger’s Superposition");
            break;
        case "first-panel":
            document.getElementById("explanation-first-panel").classList.add("highlight");
            if (secondPanel) secondPanel.material.opacity = 1; // Highlight only the first panel
            updateAnnotations("First Panel (Metal with Two Slits) - Quantum Measurement Effect");
            break;
        case "second-third-panel":
            document.getElementById("explanation-second-third-panel").classList.add("highlight");
            if (secondPanel) secondPanel.material.opacity = 1; // Highlight second panel
            if (thirdPanel) thirdPanel.material.opacity = 1; // Highlight the third panel
            updateAnnotations("Space Between the Second and Third Panel - Young’s Interference Theory");
            break;
        case "third-panel":
            document.getElementById("explanation-third-panel").classList.add("highlight");
            if (thirdPanel) thirdPanel.material.opacity = 1; // Highlight only the third panel
            updateAnnotations("Third Panel (Semiconductor – Silicon) - Electron Absorption and Energy Conversion");
            break;
    }
}

function resetHighlights() {
    // Remove highlights from text and animation parts
    document.getElementById("explanation-empty-space").classList.remove("highlight");
    document.getElementById("explanation-first-panel").classList.remove("highlight");
    document.getElementById("explanation-second-third-panel").classList.remove("highlight");
    document.getElementById("explanation-third-panel").classList.remove("highlight");

    // Reset animation part visibility or opacity
    if (firstPanel) firstPanel.material.opacity = 0.3; // Reset opacity to original state
    if (secondPanel) secondPanel.material.opacity = 0.3;
    if (thirdPanel) thirdPanel.material.opacity = 0.3;
}

function toggleExplanation() {
    const explanationBox = document.getElementById("explanation-box");
    if (explanationBox.style.display === "none" || explanationBox.style.display === "") {
        explanationBox.style.display = "block";
    } else {
        explanationBox.style.display = "none";
        resetHighlights(); // Reset highlights when the explanation box is closed
    }
}

window.onload = function() {
    init();
    // Ensure the panels and necessary variables are initialized
    if (typeof firstPanel === "undefined") {
        console.error("First panel is not initialized.");
    }
    if (typeof secondPanel === "undefined") {
        console.error("Second panel is not initialized.");
    }
    if (typeof thirdPanel === "undefined") {
        console.error("Third panel is not initialized.");
    }
};
    </script>
</body>
</html>